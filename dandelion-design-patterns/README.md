# dandelion-design-patterns -- 设计模式

## 项目结构

```
    dandelion-design-patterns
      --adapter                                        
      --bridge                               
      --builder
      --command
      --composite
      --decorator
      --facade
      --factory
      --flyweight
      --interpreter
      --iterator
      --mediator
      --memento
      --observer
      --prototype
      --proxy
      --rhainofresponsibility
      --singleton
      --state
      --strategy
      --template
      --visitor
        
```

## 说明

* **单例（Singleton）模式：** 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
    * **应用场景**
        * 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
        * 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
        * 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
        * 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
        * 频繁访问数据库或文件的对象。
        * 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
        * 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
* **原型（Prototype）模式：** 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
    * **应用场景**
        * 对象之间相同或相似，即只是个别的几个属性不同的时候。
        * 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
        * 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
        * 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。
* **工厂（Factory）模式：** 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的 ”创建与使用相分离“ 的特点。按照实际业务场景划分，工厂模式有 3
  种不同的实现方式，分别是简单工厂模式、工厂方法模式、和抽象工厂模式。
    * **简单工厂（Simple Factory）模式：**
        * **优缺点**
            * **优点**
                * 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
                * 客户端无需知道所创建具体产品的类名，只需知道参数即可。
                * 也可以引入配置文件，在不修改客户端的代码的情况下更换和添加新的具体产品类
            * **缺点**
                * 简单工厂模式的工厂类单一，所负责所有产品的创建，职责过重，一旦异常，整个系统将受影响，切工厂类代码会非常臃肿，违背高聚合原则。
                * 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。
                * 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。
                * 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构
    * **工厂方法（Factory Method）模式：** 定义一个用于创建产品的接口，由子类决定生产什么产品。
    * **抽象工厂（Abstract Factory）模式：** 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
* **建造者（Builder）模式：** 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
* **代理（Proxy）模式：** 为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
* **适配器（Adapter）模式：** 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
* **桥接（Bridge）模式：** 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
* **装饰（Decorator）模式：** 动态的给对象增加一些职责，即增加其额外的功能。
* **外观（Facade）模式：** 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
* **享元（Flyweight）模式：** 运用共享技术来有效地支持大量细粒度对象的复用。
* **组合（Composite）模式：** 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
* **模板方法（TemplateMethod）模式：** 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
* **策略（Strategy）模式：** 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
* **命令（Command）模式：** 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
* **职责链（Chain of Responsibility）模式：** 把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
* **状态（State）模式：** 允许一个对象在其内部状态发生改变时改变其行为能力。
* **观察者（Observer）模式：** 多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
* **中介者（Mediator）模式：** 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
* **迭代器（Iterator）模式：** 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
* **访问者（Visitor）模式：** 在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
* **备忘录（Memento）模式：** 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
* **解释器（Interpreter）模式：** 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

## 版本

```
    1.0      初始化,开发快照
```


